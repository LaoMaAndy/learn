#!/usr/bin/env python3
r'''
# 数据模型
    mutable， immutable 可变类型， 不可变类型
    containers 容器， 

# 对象，值与类型 Objects, values and types
    每个对象都有各自的标识号、类型和值。
    一个对象被创建后，它的 标识号 就绝不会改变
    'is' 运算符可以比较两个对象的标识号是否相同；
    id() 函数能返回一个代表其标识号的整数。
        CPython 中，id(x) 就是存放 x 的内存的地址。
    type() 返回对象的类型。与编号一样，一个对象的 类型 也是不可改变的。
    可变/不可变：
        值可以改变的对象被称为 可变对象；值不可以改变的对象就被称为 不可变对象。
        对象的可变性是由它的类型决定的：如：
            数字、字符串和元组是不可变的，而字典和列表是可变的。
    垃圾回收 gc 模块
        在对象不可访问时立即回收其中的大部分，但不保证回收包含循环引用的垃圾。
        注意：使用实现的跟踪或调试功能可能令正常情况下会被回收的对象继续存活。
            注意通过 'try...except' 语句捕捉异常也可能令对象保持存活。
        有些对象包含对 "外部" 资源的引用，例如打开文件或窗口。由于垃圾回收并不确保发生，
            这些对象还提供了明确地释放外部资源的操作，强烈推荐在程序中显式关闭此类对象。
                'try...finally' 语句和 'with' 语句提供了进行此种操作的更便捷方式。
    容器：
        容器的例子有 元组、列表和字典等。
        讨论容器的可变性时，则仅指其直接包含的对象的编号。
        一个不可变容器 (例如元组) 包含对一个可变对象的引用，则当该可变对象被改变时容器的值也会改变。
    类型：
        类型会影响对象行为的几乎所有方面。甚至对象编号的重要性也在某种程度上受到影响: 
        对于不可变类型，会得出新值的运算实际上会返回对相同类型和取值的任一现有对象的引用，
        而对于可变类型来说这是不允许的。
    是否指向相同的对象
        在 a = 1; b = 1 之后，a 和 b 可能会也可能不会指向同一个值为一的对象，这取决于具体实现，
        但是在 c = []; d = [] 之后，c 和 d 保证会指向两个不同、单独的新建空列表。
        请注意 c = d = [] 则是将同一个对象赋值给 c 和 d。

# 标准类型层级结构 The standard type hierarchy
    







'''


if __name__ == '__main__':
    print(__doc__)
    def test():
        print('data_ref.py')
    test()
