#!/usr/bin/env python3
r'''
# 数据模型
    mutable， immutable 可变类型， 不可变类型
    containers 容器， 

# 对象，值与类型 Objects, values and types
    每个对象都有各自的标识号、类型和值。
    一个对象被创建后，它的 标识号 就绝不会改变
    'is' 运算符可以比较两个对象的标识号是否相同；
    id() 函数能返回一个代表其标识号的整数。
        CPython 中，id(x) 就是存放 x 的内存的地址。
    type() 返回对象的类型。与编号一样，一个对象的 类型 也是不可改变的。
    可变/不可变：
        值可以改变的对象被称为 可变对象；值不可以改变的对象就被称为 不可变对象。
        对象的可变性是由它的类型决定的：如：
            数字、字符串和元组是不可变的，而字典和列表是可变的。
    垃圾回收 gc 模块
        在对象不可访问时立即回收其中的大部分，但不保证回收包含循环引用的垃圾。
        注意：使用实现的跟踪或调试功能可能令正常情况下会被回收的对象继续存活。
            注意通过 'try...except' 语句捕捉异常也可能令对象保持存活。
        有些对象包含对 "外部" 资源的引用，例如打开文件或窗口。由于垃圾回收并不确保发生，
            这些对象还提供了明确地释放外部资源的操作，强烈推荐在程序中显式关闭此类对象。
                'try...finally' 语句和 'with' 语句提供了进行此种操作的更便捷方式。
    容器：
        容器的例子有 元组、列表和字典等。
        讨论容器的可变性时，则仅指其直接包含的对象的编号。
        一个不可变容器 (例如元组) 包含对一个可变对象的引用，则当该可变对象被改变时容器的值也会改变。
    类型：
        类型会影响对象行为的几乎所有方面。甚至对象编号的重要性也在某种程度上受到影响: 
        对于不可变类型，会得出新值的运算实际上会返回对相同类型和取值的任一现有对象的引用，
        而对于可变类型来说这是不允许的。
    是否指向相同的对象
        在 a = 1; b = 1 之后，a 和 b 可能会也可能不会指向同一个值为一的对象，这取决于具体实现，
        但是在 c = []; d = [] 之后，c 和 d 保证会指向两个不同、单独的新建空列表。
        请注意 c = d = [] 则是将同一个对象赋值给 c 和 d。

# 标准类型层级结构 The standard type hierarchy
# None : 此类型只有一种取值。是一个具有此值的单独对象。此对象通过内置名称 None 访问。
    在许多情况下它被用来表示空值，例如未显式指明返回值的函数将返回 None。它的逻辑值为假。

# NotImplemented : 此类型只有一种取值。 是一个具有该值的单独对象。 
    此对象通过内置名称 NotImplemented 访问。 
    数值方法和丰富比较方法如未实现指定运算符表示的运算则应返回该值。 
    （解释器会根据具体运算符继续尝试反向运算或其他回退操作。） 它不应被解读为布尔值。

# Ellipsis : 此类型只有一种取值。是一个具有此值的单独对象。此对象通过字面值 ... 或内置名称 
    Ellipsis 访问。它的逻辑值为真。

# numbers.Number : 此类对象由数字字面值创建，并会被作为算术运算符和算术内置函数的返回结果。
    数字对象是不可变的；一旦创建其值就不再改变。
        from numbers import Number
        isinstance(7, numbers.Number)
        >>> True
        issubclass(int, numbers.Number)
        >>> True
    数字类的字符串表示形式，由 __repr__() 和 __str__() 算出，具有以下特征属性:
        它们是有效的数字字面值，当被传给它们的类构造器时，将会产生具有原数字值的对象。
        表示形式会在可能的情况下采用 10 进制。
        开头的零，除小数点前可能存在的单个零之外，将不会被显示。
        末尾的零，除小数点后可能存在的单个零之外，将不会被显示。
        正负号仅在当数字为负值时会被显示。

## numbers.Integral
    此类对象表示数学中整数集合的成员 (包括正数和负数)。
        整型数可细分为两种类型:
    整型 (int)
        此类对象表示任意大小的数字，仅受限于可用的内存 (包括虚拟内存)。在变换和掩码运算中会以二进制表示，
        负数会以 2 的补码表示，看起来像是符号位向左延伸补满空位。
    布尔型 (bool)
        此类对象表示逻辑值 False 和 True。代表 False 和 True 值的两个对象是唯二的布尔对象。
        布尔类型是整型的子类型，两个布尔值在各种场合的行为分别类似于数值 0 和 1，
        例外情况只有在转换为字符串时分别返回字符串 "False" 或 "True"。
    整型数表示规则的目的是在涉及负整型数的变换和掩码运算时提供最为合理的解释。

## numbers.Real (float)
    此类对象表示机器级的双精度浮点数。其所接受的取值范围和溢出处理将受制于底层的机器架构 (以及 C 或 Java 实现)。
    Python 不支持单精度浮点数；支持后者通常的理由是节省处理器和内存消耗，
    但这点节省相对于在 Python 中使用对象的开销来说太过微不足道，因此没有理由包含两种浮点数而令该语言变得复杂。

## numbers.Complex (complex)
    此类对象以一对机器级的双精度浮点数来表示复数值。有关浮点数的附带规则对其同样有效。
    一个复数值 z 的实部和虚部可通过只读属性 z.real 和 z.imag 来获取。

# 序列 Sequences
    此类对象表示以非负整数作为索引的有限有序集。
    内置函数 len() 可返回一个序列的条目数量。
    序列还支持切片: a[i:j] 选择索引号为 k 的所有条目，i <= k < j。
        当用作表达式时，序列的切片就是一个与序列类型相同的新序列。新序列的索引还是从 0 开始。
    有些序列还支持带有第三个 "step" 形参的 "扩展切片": a[i:j:k] 
        选择 a 中索引号为 x 的所有条目，x = i + n*k, n >= 0 且 i <= x < j。
    序列可根据其可变性来加以区分:

## 不可变序列 Immutable sequences
    不可变序列类型的对象一旦创建就不能再改变。以下类型属于不可变对象:

    ### 字符串 Strings
        字符串是表示 Unicode 代码点的值序列。 U+0000 - U+10FFFF 范围内的所有代码点都可以用字符串表示。 
        Python 没有 char 类型；
        字符串中的每个代码点都表示为长度为 1 的字符串对象。
        内置函数 
            ord() 将代码点从字符串形式转换为 0 - 10FFFF 范围内的整数
            chr() 将 0 - 10FFFF 范围内的整数转换为相应长度的 1 字符串对象。
            str.encode() 可用于使用给定的文本编码将 str 转换为 bytes ，而 
            bytes.decode() 可用于实现相反的效果。

    ### Tuples 元组    
        一个元组中的条目可以是任意 Python 对象。包含两个或以上条目的元组由逗号分隔的表达式构成。
        只有一个条目的元组 ('单项元组') 可通过在表达式后加一个逗号来构成 
        (一个表达式本身不能创建为元组，因为圆括号要用来设置表达式分组)。
        一个空元组可通过一对内容为空的圆括号创建。

    ### Bytes 字节串
        字节串对象是不可变的数组。其中每个条目都是一个 8 位字节，以取值范围 0 <= x < 256 的整型数表示。字节串字面值 (例如 b'abc') 和内置的 bytes() 构造器可被用来创建字节串对象。字节串对象还可以通过 decode() 方法解码为字符串。

## 可变序列 Mutable sequences
    可变序列在被创建后仍可被改变。下标和切片标注可被用作赋值和 del (删除) 语句的目标。
    目前有两种内生可变序列类型:

    ### Lists 列表
        列表中的条目可以是任意 Python 对象。列表由用方括号括起并由逗号分隔的多个表达式构成。
        (注意创建长度为 0 或 1 的列表无需使用特殊规则。)

    #### Byte Arrays 字节数组
        字节数组对象属于可变数组。可以通过内置的 bytearray() 构造器来创建。
        除了是可变的 (因而也是不可哈希的)，在其他方面字节数组提供的接口和功能都与不可变的 bytes 对象一致。
        扩展模块 array : 扩展模块提供了一个额外的可变序列类型示例
            collections 扩展模块也是如此。

# 集合类型 Set types
    此类对象表示由不重复且不可变对象组成的无序且有限的集合。因此它们不能通过下标来索引。
    但是它们可被迭代，也可用内置函数 len() 返回集合中的条目数。
    集合常见的用处是：
        快速成员检测，
        去除序列中的重复项，
        以及进行交、并、差和对称差等数学运算。
    对于集合元素所采用的不可变规则与字典的键相同。
    注意数字类型遵循正常的数字比较规则: 
        如果两个数字相等 (例如 1 和 1.0)，则同一集合中只能包含其中一个。
    目前有两种内生集合类型:
    ## 集合 Sets
        此类对象表示可变集合。它们可通过内置的 set() 构造器创建，
        并且创建之后可以通过方法进行修改，例如 add()。
    ## 冻结集合 Frozen sets 
        此类对象表示不可变集合。它们可通过内置的 frozenset() 构造器创建。
        由于 frozenset 对象不可变且 hashable，它可以被用作另一个集合的元素或是字典的键。

# 映射 Mappings 
    此类对象表示由任意索引集合所索引的对象的集合。
        通过下标 a[k] 可在映射 a 中选择索引为 k 的条目；
        这可以在表达式中使用，也可作为赋值或 del 语句的目标。
        内置函数 len() 可返回一个映射中的条目数。
    目前只有一种内生映射类型:
    ## 词典 Dictionaries 
        此类对象表示由几乎任意值作为索引的有限个对象的集合。
        不可作为键的类型为可变类型，包括列表或字典或其他。
            通过值而非对象编号进行比较的值，其原因在于高效的字典实现需要使用键的哈希值以保持一致性。
        可用作键的数字类型遵循正常的数字比较规则: 如果两个数字相等 (例如 1 和 1.0) 则它们均可来用来索引同一个字典条目。
        字典会保存插入顺序，这意味着键将以它们被添加的顺序在字典中依次产生。
            替换某个现有的键不会改变其顺序，
            但是移除某个键再重新插入则会将其添加到末尾而不会保留其原有位置。
        字典是可变的；它们可通过 {...} 标注来创建
        扩展模块 dbm.ndbm 和 dbm.gnu 提供了额外的映射类型示例，
            collections 模块也是如此    
        备注： 在 Python 3.6 版之前字典不会保留插入顺序。 
            在 CPython 3.6 中插入顺序会被保留，但这在当时被当作是一个实现细节而非确定的语言特性。

# 可调用类型 Callable types
    此类型可以被应用于函数调用操作

## 用户定义函数 User-defined functions 
    用户定义函数对象可通过函数定义来创建 (参见 函数定义 小节)。
    函数名 ： 代表函数对象， 用户定义函数对象 user-defined function object
    函数调用 ： 使用函数名加括号内的参数列表。
    它被调用时应附带一个参数列表，其中包含的条目应与函数所定义的形参列表一致。
    特殊属性：
        __doc__ ，可写， 该函数的文档字符串，没有则为 None；不会被子类继承。
        __name__ ，可写， 该函数的名称。
        __qualname__  ，可写， 该函数的 qualified name。3.3 新版功能.
        __module__ ， 可写， 该函数所属模块的名称，没有则为 None。
        __defaults__ ， 可写， 由具有默认值的参数的默认参数值组成的元组，如无任何参数具有默认值则为 None。
        __code__ ， 可写， 表示编译后的函数体的代码对象。
        __globals__ ， 只读， 对存放该函数中全局变量的字典的引用，即：函数所属模块的全局命名空间。
        __dict__ ， 可写， 命名空间支持的函数属性。
        __closure__ ， 只读， None 或包含该函数可用变量的绑定的单元的元组。有关 cell_contents 属性的详情见下。
        __annotations__ ， 可写， 包含形参标注的字典。 字典的键是形参名，而如果提供了 'return' 则是用于返回值标注。 
                        有关如何使用此属性的更多信息，请参阅 对象注解属性的最佳实践。
                        https://docs.python.org/zh-cn/3/howto/annotations.html#annotations-howto
        __kwdefaults__ ， 可写， 仅包含关键字参数默认值的字典。
    
    函数对象也支持获取和设置任意属性，例如这可以被用来给函数附加元数据。
        函数对象新增的属性 与 函数内置属性不同。 
        目前函数无法调用函数对象新增的属性。
        使用正规的属性点号标注获取和设置此类属性。
        注意当前实现仅支持用户定义函数属性。未来可能会增加支持内置函数属性。
        def foo():
            s = str()
            # 以上效果相同，显示函数内部属性
            print('vars()')
            print(locals()) 

            # 以下效果相同，显示函数对象属性
            print(foo.__dict__)
            print(vars(foo)) 
    (?)cell object具有 cell_contents 属性。这可被用来获取以及设置单元的值。

## 实例方法 Instance methods
    实例方法 与 实例方法对象
    实例方法，即 : 实例.方法名
    实例方法用于结合类、类实例和任何可调用对象 (通常为用户定义函数)。
    特殊只读属性：
        __self__ 为类实例对象本身
        __func__ 为函数对象
        __doc__ 为方法的文档 (与 __func__.__doc__ 作用相同)
        __name__ 为方法名称 (与 __func__.__name__ 作用相同)；
        __module__ 为方法所属模块的名称，没有则为 None。
    方法还支持获取 (但不能设置) 下层函数对象的任意函数属性。
    当一个实例方法对象被调用时，会调用对应的下层函数 (__func__)，
        并将类实例 (__self__) 插入参数列表的开头。
        例如，当 C 是一个包含了 f() 函数定义的类，而 x 是 C 的一个实例，
            则调用 x.f(1) 就等同于调用 C.f(x, 1)。
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    当实例方法对象派生自类方法对象时，存储在 __self__ 中的“类实例”实际上是类本身，
        因此调用 x.f(1) 或 C.f(1) ，其中 f 是底层函数。
    (此处有疑惑，需要再仔细研读)

## 生成器函数 Generator functions 
    一个使用 yield 语句（见 yield 语句 章节）的函数或方法被称为 生成器函数。 
        这样的函数在被调用时，总是返回一个可以执行该函数体的 iterator 对象：
        调用该迭代器的 iterator.__next__() 方法将导致这个函数一直运行
        到它使用 yield 语句提供一个值。 
    当这个函数执行 return 语句或到达函数体末尾时，将引发 StopIteration 异常
        并且该迭代器将到达所返回的值集合的末尾。
    https://docs.python.org/zh-cn/3/reference/simple_stmts.html#yield

## 协程函数 Coroutine functions 
    使用 async def 来定义的函数或方法就被称为 协程函数。这样的函数在被调用时会返回一个 coroutine 对象。
        它可能包含 await 表达式以及 async with 和 async for 语句。
        详情可参见 协程对象 一节。
    https://docs.python.org/zh-cn/3/reference/datamodel.html#coroutine-objects

## 异步生成器函数 Asynchronous generator functions
    使用 async def 来定义并使用了 yield 语句的函数或方法被称为 异步生成器函数。 
        这样的函数在被调用时，将返回一个 asynchronous iterator 对象，
        该对象可在 async for 语句中被用来执行函数体。
    调用异步迭代器的 aiterator.__anext__ 方法将返回一个 awaitable，
        此对象会在被等待时执行直到使用 yield 产生一个值。 
        当函数执行到空的 return 语句或函数末尾时，
        将会引发 StopAsyncIteration 异常并且异步迭代器也将到达要产生的值集合的末尾。

## 内置函数 Built-in functions
    内置函数对象是对于 C 函数的外部封装。
    内置函数的例子包括 len() 和 math.sin() (math 是一个标准内置模块)。
    内置函数参数的数量和类型由 C 函数决定。
    特殊的只读属性: 
        __doc__ 是函数的文档字符串，如果没有则为 None; 
        __name__ 是函数的名称; 
        __self__ 设定为 None (参见下一条目); 
        __module__ 是函数所属模块的名称，如果没有则为 None。

## 内置方法 Built-in methods
    此类型实际上是内置函数的另一种形式，只不过还包含了一个传入 C 函数的对象作为隐式的额外参数。
    内置方法的一个例子是 alist.append()，其中 alist 为一个列表对象。
    在此示例中，特殊的只读属性 __self__ 会被设为 alist 所标记的对象。

## 类 Classes
    类是可调用对象。 这些对象通常是用作创建自身实例的“工厂”，
    但类也可以有重载 __new__() 的变体类型。调用的参数会传递给 __new__()，
    并且在通常情况下，也会传递给 __init__() 来初始化新的实例。

## 类实例 Class Instances
    任意类的实例可以通过在其所属类中定义 __call__() 方法变成可调用对象。
    在类中定义一个函数：
        def __call__(self): ...
    即可对类对象进行调用：
        c = MyClass()  c()

# 模块 Modules
    由 import 语句发起调用，或者通过 importlib.import_module() 和内置的 __import__() 等函数发起调用。
    模块中的字典对象：
        块对象具有由字典对象实现的命名空间，也就是模块中函数的 __globals__ 属性引用的字典
        属性引用被转换为该字典中的查找，例如 m.x 相当于 m.__dict__["x"]
        属性赋值会更新模块的命名空间字典，例如 m.x = 1 等同于 m.__dict__["x"] = 1。
    模块对象不包含用于初始化模块的代码对象（因为初始化完成后不需要它）。
    预先定义的（可写）属性:
        __name__ : 模块的名称。
        __doc__  : 模块的文档字符串，如果不可用则为 None。
        __file__ : 被加载模块所对应文件的路径名称，如果它是从文件加载的话。 
                    对于某些类型的模块来说 __file__ 属性可能是缺失的，
                    例如被静态链接到解释器中的 C 模块。 
                    对于从共享库动态加载的扩展模块来说，它将是共享库文件的路径名称。
        __annotations__ : 包含在模块体执行期间收集的 变量标注 的字典。 
                    有关使用 __annotations__ 的最佳实践，请参阅 对象注解属性的最佳实践。
        __dict__ : 特殊的只读属性, 为以字典对象表示的模块命名空间。
                    CPython 实现细节： 由于 CPython 清理模块字典的设定，
                    当模块离开作用域时模块字典将会被清理.

# 自定义类
    
# 类实例
# I/O 对象 (或称文件对象)
# 内部类型
## 代码对象
## 帧对象
## 回溯对象
## 切片对象
## 静态方法对象
## 类方法对象

# 特殊方法名称
## 基本定制
## 自定义属性访问
## 自定义模块属性访问
## 实现描述器
## 调用描述器
## __slots__
### 使用 __slots__ 的注意事项
## 自定义类创建
### 元类
###  解析 MRO 条目
### 确定适当的元类
### 准备类命名空间
### 执行类主体
### 创建类对象
### 元类的作用
## 自定义实例及子类检查
## 模拟泛型类型
### __class_getitem__ 的目的
### __class_getitem__ 与 __getitem__
## 模拟可调用对象
## 模拟容器类型
## 模拟数字类型
## with 语句上下文管理器
## 定制类模式匹配中的位置参数
## 特殊方法查找
# 协程
## 可等待对象
## 协程对象
## 异步迭代器
## 异步上下文管理器


'''


if __name__ == '__main__':
    print(__doc__)
    def test():
        print('data_ref.py')
    test()
